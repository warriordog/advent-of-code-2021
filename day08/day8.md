# Day 8: Seven Segment Search

### Part 1
My Part 1 solution was pretty straightforward - just some input parsing (that I reused in part 2) and a map from "number of digits" to "numbers that have that many digits". I took each input, applied it to the map, and counted the number of times where there was exactly one matching number.

### Part 2
Part 2 was one of the hardest AOC puzzles that I've ever done. I don't think that it *should* have been this hard, but it was.  I kept getting confused about which way my mappings worked (scrambled -> real versus real -> scrambled). I also spent way too long trying to code a purely analytical solution before I finally realized that I could just get "close enough" and then brute force the rest. So that's what I did. My part 2 solution works like this (for each input separately):

1. I identify the numbers 1, 4, and 7 in the input based on length. 8 is ignored because it includes all digits and is thus useless for my algorithm.
2. For each "real" digit (a - g), I compute a list of "encoded" digits that could possibly map to it. This is done by treating the list of digits in each identified number as a boolean "exists" flag. For example, "a" exists in 7 but not 1 or 4, so the list of possible encodings for "a" is the list of digits that exist 7's input but *not* in 1 or 4's. This is repeated for each digit, and I'm eventually left with a greatly reduced input search space (typically 1-3 possible encodings per digit).
3. I brute force the remaining possibilities using an ugly mess of nearly-recursive loops. Each digit (starting with a) has a "brute force" function that accepts the current value of all previous digits and passes them into the next function along with a possible value for its own digit. Once we reach `bruteForceRemainingG` (the terminal case), a mapping object is created and stored in an array. Then the next configuration is tried, and the next, until every possible configuration is stored in the array.
4. The correct solution is identified from the superset list by testing each potential solution against the input. Since we are given exactly one example of every digit, we can expect that exactly one configuration will decode to all 10 unique numbers. That mapping is found, and then pivoted so that the key is the encoded digit (rather than the real digit).
5. A decoder is generated by taking each number's digit configuration and applying that to the pivoted mapping. The resulting digits are concatenated into a string and used as the index into a key->value store, where the key is an input string and the value is a number.
6. Each input reading is passed to the decoder, and the resulting value is stringified, concatenated, and finally parsed back into the actual value.

I'm sure there are better ways to solve this, but my solution works and I'm happy with it.